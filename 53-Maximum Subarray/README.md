## 题意
   给你一个数组，然后让你找出一个子序列（至少包含一个数字），使得它有最大的和并返回这个最大的和。
   
## 思路
   **Solution-1**
   
   直接 for 一遍，然后保持一个初始的计数器 sum=0，然后在遍历的过程中，如果 sum+a[i]>=0，那么说明当前 sum 在加了这个数 a[i] 之后还是
   保持大于等于 0，那么 sum 对于后面还是会产生正向的作用的，你想，万一再加一个正数，sum 的值不就更大了吗？
   
   如果 sum+a[i]<0，说明 sum 加了这个数使它小于 0 了，那么再利用这个 sum 去加后面的 a[i] 会产生负向作用，比如说 sum 去加一个正的 a[i]，
   那不是让那个 a[i] 亏损了吗？所以这个时候我们果断抛弃这个 sum，并将它清空为 0。
   
   总结一下，1) sum+a[i]>=0, sum=sum+a[i]; &nbsp;&nbsp;  2) sum+a[i]<0, sum=0;
   
   在遍历的过程中，同时记录下最大值 lmax (**但是要注意 lmax 的初值，要将其赋值为 a[0]，而不是 0，要想万一这个数组全是负数对吧？！**) 并进行不断的更新。
   
   </br>
   
   **Solution-2**
   
   因为这道题打着 Divide and Conquer 的 Tag，所以我也尝试了一下分治算法，想了好久= =||
   
   思路参考: https://www.geeksforgeeks.org/divide-and-conquer-maximum-sum-subarray/
   
   这道题的思路和 169 的分治很像（可以去参考 169 画的递归图），但是主要就是难在合并两个区间的过程。
   
   这道题的结束条件是 l==r，也就是左右区间相等的时候，那个时候的最大区间和肯定就是自身，所以是 nums[l]。
   
   然后就是合并的时候，分为 3 个情况：
   
   1）左边区间的区间和最大
   
   2）右边区间的区间和最大
   
   3）找从中间点开始的往左右两边扩散的最大和
   
   第 3 种，为什么呢？因为我们左右区间的区间最大和都已经求出来了，只剩下中间开始的区间的了，那么怎么求中间开始的区间的最大序列和呢？
   
   那么就直接从中点 mid 开始分别往左右两边遍历，然后把左右两边的最大子序列和加起来就是中间开始的最大子序列和了。
   
   最后返回到每个区间的时候，就取这 3 个条件中的最大值就可以了！
   
   大致图解如下：
   
   ![image](https://user-images.githubusercontent.com/16880879/42164229-f3ff1836-7e37-11e8-876f-d4921d7b6ae5.png)
