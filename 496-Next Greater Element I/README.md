## 题意
   给两个数组nums1和nums2，然后nums1中的数字都是nums2中的子序列。然后让你对于nums1中的数字X，在nums2中去寻找对应的比这个数字X大的数字，
   并且位置要在X的右边，如果没有找到，那么返回-1.
   
## 思路
   1. O(N^2)
   
   就是首先遍历nums2中的数字，然后利用map记录下每个值对应的位置；
   
   然后再遍历nums1，对于每个数字，利用map获取到它的位置，（当然这里需要用 mp.count(X) 来判断一下这个数在map中是否存在），然后再往后遍历nums2中数字，
   如果有比它大的数，那么就放到vector中，反之，就放入-1.
   
   2. O(N)
   
   第二种有点巧妙，用到了栈（stack）。以及利用了map来记录比当前数大的数的值。
   
   首先遍历nums2中的数字，然后判断栈是否为空，如果为空的话，那么就把当前数字放进去；
   
   如果不为空，且当前栈顶的数字比nums2中当前遍历到的数字小的话，那么就利用map记录当前栈顶的next比它大的数字为当前遍历到的数字，并弹出栈。
   
   这样不断弹出之后，直到栈中不存在比当前遍历到的数字小的数，那么再把当前遍历到的数字压入栈。
   
   最后遍历一下nums1，判断在 mp 中该值所对应的 key 是否存在（存在为1，不存在为0），存在赋值为mp[nums[i]]，反之则给它-1.
   
   
## 收获
   map，stack
