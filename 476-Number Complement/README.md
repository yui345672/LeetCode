## 题意
   就是给你一个十进制的数（保证在32位以内），然后让你把它转化成二进制的格式，然后再将二进制的格式进行翻转（比如原来是0的，变成1；反之亦然），
   
   然后再把这个二进制进行转化成十进制。最后输出这个十进制数。
  
  
## 思路
   很简单。就按照它说的来就好了。
   
   
## 收获
   有些符号都记不太得了。
   
   C++里面的**位运算符**。二进制的左移运算符和右移运算符。
   
   二进制左移运算符 << : 就是在二进制中向左移动相应的位数。
   
   例如：1<<3，那么就是0001的1向左移动3个位数变成 1000，那么最后就是2^3=8
   
   同理二进制右移运算符 >> 就是在二进制中向右移动相应的位数。
   
   注意：符号都是保留的，比如说是负号还是正号。
   
   其实右移相当于是除以2；所以我们可以用位移运算符来代替除法操作。
   
   而对于左移则是在1<<2左移的时候适用，相当于是2^2，可以代替平方运算。
   
   ref: https://baike.baidu.com/item/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6

   根据位运算符来写的代码：
   
   ```c++
   class Solution {
public:
    int findComplement(int num) {
        int res=1;
        int tmp=num;
        while(tmp){
            res=res<<1;
            tmp=tmp>>1;
        }
        return num^(res-1);
    }
};
   ```
   
   因为最后想使用的是异或运算，所以最后肯定二进制数要有相同的位数，以及所有位数都必须为1，因为只有与1进行亦或才会变成相反的数。
   
   res一开始为1，然后不停的向左移动1位；最后会比num的二进制多一位；所以这里最后 res-1 ，相当于是二进制回退了一位，
   
   比如说二进制 1000 的十进制是8，然后减1之后十进制变成了7，它的二进制就变成了111，这个可以从计算机的进位来想。
   
   二进制 111 进了一位之后就变成了 1000。因为它是逢2进1嘛~
   
   所以这道题还是有给我带来收获的。
