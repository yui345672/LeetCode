## 题意
   现在你有 n 个硬币，然后你要将它构建成一个梯子的形状，要保证第 k 层有 k 个硬币。
   
   并找出最多能够构建几层这样的硬币。
   
## 思路
   先举几个例子看看，比如说梯子的形状是：
   
   1,2,3,4,5,6,7,8,9  &nbsp; &nbsp;&nbsp;   那么此时总共需要 45 个硬币才能完成这个形状。
   
   因为第 k 层拥有的硬币数量为 k 个，所以因为这是一个等差数列，所以直到 k 层所需要的硬币数量总共为 Sk=(k+1)*k/2 个。
   
   所以很显而易见，我们只需要解这个方程： Sk <= n ，然后求得最多能够构造的层数 k 就可以了。
   
   1）可以遍历去找 k 的值使之满足这个方程式。
   
   2）使用求根公式来求出 k 的值，因为 k 肯定是非负的，所以有一个是一定要被抛弃的。
   
   3）使用二分法来遍历答案区间，然后求出需要几层。
   
   区间的范围是 [ 0, sqrt(2*n) ] ， 一开始我想的是右区间为 n ，但是在后面的计算中 n*(n+1) 有可能会溢出。
   
   sqrt(2*n) 是通过不等式得来的:
   
   x^2 <= x^2+x <= 2*n ， 因为我们要让右区间尽量能够覆盖到 2*n ，所以 x^2 <= 2*n 得到 x <= 根号(2*n) 就可以了。
   
   确定了二分区间之后，因为这个问题是要找最大的 k 使 Sk <= n ， 所以问题可以转化为找最小的 k 使 Sk > n ，然后将最后得到的指针 -1 就是答案。
   
   为什么不直接去找最大的 k 使之满足 Sk <= n 呢？
   
   因为写法的关系，如果要去找最大的 k ，那么当 f(mid) <= n 时， left=mid ； 而当 f(mid) > n 时， right=mid-1 ；
   
   这个看似没有问题，但是因为 mid = (left+right)/2 ，所以很多时候 mid 都是向下进行取整的，比如说 left=3, right=4， 那么 mid 很容易就会卡死在
   (3+4)/2=3 这里，所以循环的 mid 永远都取不到 mid=4 ，这样就结束不了循环。所以一般都是对 left 进行操作。
   
   错误的代码见下面 (这份代码里面还有溢出的问题没有处理) ，还是理解不了的可以手动进行模拟一下：
   
   ```c++
   class Solution {
    public:
    int arrangeCoins(int n) {
        int left=0, right=n, mid;
        while(left<right){
            mid=left+(right-left)/2;
            if(f(mid)<=n){
                left=mid;
            }else if(f(mid)>n){
                right=mid-1;
            }
        }
        return left;
    }
    long long f(int n){
        return (n*n + n)/2;
    }
};
   ```
