## 题意
   给你两个字符串 S 和 T，它们都只包含小写字母。
   
   然后 T 是由 S 中的字母变化顺序而来，然后又加了一个另外的字母。
   
   最后让你找到那个多出来的字母。
   
## 思路
   顺带学习了一下 Hash，它就是通过一个散列函数将数字 / 字母映射到散列表中，这样就能够实现 O(1) 的查找了，
   但是 Hash 会有时发生冲突，这时候就需要用到一些方法，一般使用的是线性探查法、平方探查法和链地址法。
   一开始我还想要自己实现这些东西会不会有些复杂，但是后来发现在 C++ 中这些都已经给我们封装好了，就是我们
   常用到的 map 和 unordered_map，其中 unordered_map 的速度更快。
   
   Solution-1：
   
   这个方法的代码写的有点累赘，因为没有注意到 T 就比 S 多了一个字符，所以还遍历了那么多次。
   
   Solution-2：
   
   注意到题目中说 t 是由 s 变化过来，然后再加上一个字符，
   所以 t 肯定比 s 多一个字符，而且 t 中有的 s 里面肯定也有，
   
   **所以最后记录下来只出现过奇数次的字符就是我们要找的!**
   
   然后最后还有 unordered_map 的遍历，注意是要通过迭代器来进行遍历，而不是利用 for 遍历 mp.size() 这样。
   所以这个要注意，我在最后取出那个多于字符的时候出现了错误，错了两次！
   
   然后 auto 关键字就是说我们可以不写如下的东西，而是直接用 auto 关键字代替这些就好了，更简便了！
   
   ```c++
   std::map<char,int>::iterator it=mymap.begin();
   ```
