## 题意
   给你一个数组和一个值 val，让你删掉在数组中的所有这个数，并返回最后的长度。
   
   * 注意：不允许复制 array，或者另外开创一个数组，需要保证空间复杂度为 O(1)，也就是说只允许在原来的数组上进行修改的操作。
   
   * 数组的顺序可以进行任意的改变。
   

## 思路
   1.第一种思路和 283 很像，首先先找到第一个出现与 val 一样值的位置，然后记录下来这个位置 idx，并且数组的长度 len-1；
   然后当遍历到后面的数字不是 val 时，再把它放到 idx 这个位置，然后 idx 位置下标 ++，进行下一个位置的覆盖。
   
   2.第二种思路和上面一样，只不过没有记录第一个出现和 val 一样值的位置，而是直接从 0 开始，
   将值不等于 val 的数组内容压入到 nums[idx] 中，然后 idx 下标 ++。
   
   3.最后一种思路有点巧妙：
   
   首先，我们从开头进行遍历，如果当前遍历到的数的值和 val 一样，那么就将该位置的数和数组最后一个位置的数进行交换，
   然后将数组的长度减 1，因为最后一个数不是不需要了嘛。
   
   然后你可能会说，万一换过来的数也是和 val 一样怎么办？不要紧，因为我们这里并没有将 i 减 1，所以 i 还是在之前那个遍历到的数的位置，
   然后我们在下一次的遍历时候，会再判断一次 nums[i] 是不是等于 val，如果换了之后还是一样，那么继续换，重复之前的步骤，将数组的长度减 1。
   
   直到换到当前的数不再等于 val 了，那么我们进行下一个位置的遍历，将 i++ 即可。
   
   然后不断遍历，重复上述步骤，直到结束~
