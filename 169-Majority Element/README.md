## 题意
   给你一个数组，大小为 n ，然后让你找出这个数组中的「majority element」，它是在数组中出现次数超过 n/2 的次的那个数。（n/2 向下取整）
   题目保证「majority element」肯定存在。
   
## 思路
   **Solution-1**
   
   使用 HashMap 来记录每个数字出现的次数，然后最后再遍历一下 Map，然后就可以得到出现次数超过 n/2 次的那个数。
   
   **Solution-2**
   
   使用**Boyer-Moore Voting 算法**
   
   想了两天，终于想明白了。
   
   假设数组中的每个不同的数字都是不同的群体成员，然后我们要根据每个群的人数，然后找到人数最多的那个群作为 majority element。
   
   **因为 majority element 出现的次数是大于 n/2 的，所以如果一个群体是 majority 的话，那么无论别人怎么打压它，它都能够最后保留下来。**
   
   1.首先呢，我们假设第一个数是 majority element，然后将 count 指针指向它，并标记这个军团（假设为 A）人数加 1。
   
   2.然后将指针指向下一个人，如果发现，哎，是自己人，那么说明当前这个指针所指向的也是这个 A 军团的人，所以 count 继续加 1。
   
   3.如果发现不是自己人，那么我们派人去对抗，对抗完了两个人都阵亡了，这个时候 count 要减 1，代表 A 军团损失了一名成员。
   
   4. 如果对抗完了发现 A 军团的人没了（也就是 count==0），这个时候 A 军团暂时灭亡（因为还没遍历到后面所以不知道还有没有 A 的人）。
   
   5.然后我们将指针指向下一个，因为之前 A 已经阵亡了，所以此时 count 为 0，因为没有人了呀，然后再次假设当前这个数是 majority element，然后重复 1-4 的步骤。
   
   6.最后剩下的就是那个 majority element，但是要注意的是，可能会有特例：比如说“1 2 1 2 3”，最后通过该算法得到的可能是 3，但是 3 并不是
   majority element，所以这时我们还需要进行复查，也就是说再结束了 Boyer-Moore 投票算法之后再在整个数组中查一下是不是 3 在整个数组中出现次数
   大于 n/2。
   
   **Solution-3**
   
   使用 Divide and Conquer （分而治之算法），我们可以将问题分解成找到某一部分的区间内**出现次数最多的一个数**。
   然后问题就是如果要合并两个区间的话怎么办？
   
   1.如果左区间和右区间找到的出现次数最多的一个数是一样的，那么当前区间直接就采用这个数，直接合并就好。
   
   2.如果两个区间找到的出现次数最多的数是不同的，那么你得将左区间找到的数 NumL 和右区间找到的数 NumR 在当前的 [l,r] 区间内去遍历一遍，
   看到底是 NumL 出现的多，还是 NumR 出现的次数多，然后把出现次数多的那个数赋值给当前的区间。
   
   递归的过程大致如下图所示（主要是合并的时候有点难想）：
   ![image](https://user-images.githubusercontent.com/16880879/42125634-4a9fdc48-7cad-11e8-8590-f9b5ab25ba35.png)
