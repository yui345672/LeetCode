## 题意
   给你一个数组，大小为 n ，然后让你找出这个数组中的「majority element」，它是在数组中出现次数超过 n/2 的次的那个数。（n/2 向下取整）
   题目保证「majority element」肯定存在。
   
## 思路
   **Solution-1**
   
   使用 HashMap 来记录每个数字出现的次数，然后最后再遍历一下 Map，然后就可以得到出现次数超过 n/2 次的那个数。
   
   **Solution-2**
   
   使用**Boyer-Moore Voting 算法**
   
   因为我们要找的是出现次数超过 n/2 的数，所以我们将指针指向第一个数，并用计数器 count 标记它的出现次数为 1，然后如果后面那个数和前面那个
   数的值不一样，那么说明它们两个是不同的，所以 count 就进行减 1 的操作，
   
   这个算法得补。。。因为还是没有太想明白这个为什么是对的？
   
   **Solution-3**
   
   使用 Divide and Conquer （分而治之算法），我们可以将问题分解成找到某一部分的区间内**出现次数最多的一个数**。
   然后问题就是如果要合并两个区间的话怎么办？
   
   1.如果左区间和右区间找到的出现次数最多的一个数是一样的，那么当前区间直接就采用这个数，直接合并就好。
   
   2.如果两个区间找到的出现次数最多的数是不同的，那么你得将左区间找到的数 NumL 和右区间找到的数 NumR 在当前的 [l,r] 区间内去遍历一遍，
   看到底是 NumL 出现的多，还是 NumR 出现的次数多，然后把出现次数多的那个数赋值给当前的区间。
   
   递归的过程大致如下图所示（主要是合并的时候有点难想）：
   ![image](https://user-images.githubusercontent.com/16880879/42125634-4a9fdc48-7cad-11e8-8590-f9b5ab25ba35.png)
