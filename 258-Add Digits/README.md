## 题意
   给一个非负整数 num，反复地把它每个位上的数字加起来，直到最终结果只剩下一个数字了。
   
   例如：数字 38 -> 3 + 8 = 11, 1 + 1 = 2. 
   
## 思路
   1.暴力的话就很简单了嘛，因为我这里假设它最多只是 int 型，所以每个位数上的数字加起来最多只可能会有 2 位，
   所以最多只要进行 2 次这样的操作就可以将数字变成 1 位。
   
   </br>
   2.这道题可以通过一个 数学公式 来解决。叫做「数字根」，英文叫做 Digital Root.
   
   「数字根」就是最后剩下的那个数字就叫做数字根。
   
   
   </br>
   
   首先给出**公式**：
   
   当数字为 0 的时候，就直接返回 0。（因为它只有一位）
   
   当数字为 9 的倍数时（也就是能被 9 整除），返回 9。
   
   其他的条件下，就返回 num % 9 ，也就是该数 % 9 之后的余数。
   
   </br>
   
   解释：
   
   比如说一个数 12345， 我们可以将其写成如下的形式：
   
   12345 = 1 * 10000 + 2 * 1000 + 3 * 100 + 4 * 10 + 5 * 1
   
   这个应该没有什么争议吧，因为一个数就是由每位上的数堆叠起来的。
   
   然后呢，我们对上面的形式进行一下修改，得到：
   
   12345 = 1 * (9999 + 1) + 2 * (999 + 1) + 3 * (99 + 1) + 4 * (9 + 1) + 5 * 1
   
   12345 = (9999 * 1 + 1) + (999 * 2 + 2) + (99 * 3 + 3) + (9 * 4 + 4) + 5
   
   12345 = (9999 * 1 + 999 * 2 + 99 * 3 + 9 * 4) + (1 + 2 + 3 + 4 + 5)
   
   发现了吗？ 前面一个括号中的 9 可以被提出，所以如果当这个式子 % 9 之后，前面那一部分是 0，
   而重要的是后面那一部分，就是每一位数的相加，这也是我们想要的。
   
   那么你可能会问？如果后面每一位数的相加大于 10 怎么办？那不是还要再进行一次这样的操作？
   
   对的，但是取模就相当于是得到最后的结果，你可以想象成不断把这个式子展开，然后每次前半部分就是取模 9 之后就变成 0，
   留下的就是后面的每位数相加和的部分，所以到最后剩下的就是加起来为个位数的数字啦~
   
   </br>
   参考：http://www.flyingcoloursmaths.co.uk/a-neat-number-trick-digital-roots-and-modulo-9-arithmetic/
   
   ![image](https://user-images.githubusercontent.com/16880879/40968012-1fc61408-68e7-11e8-864f-242d155bc342.png)
   
   https://www.zhihu.com/question/30972581
